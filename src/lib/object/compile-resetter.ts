export function compileResetter<T extends object>(obj: T) {
    const pathsAndValueLiterals = collectPathsAndValueLiterals(obj, [], []);

    return new Function(
        "obj",
        `// Generated by src/lib/object/compile-resetter.ts
// compileResetter
${pathsAndValueLiterals.map(({ path, valueLiteral }) => `obj.${path.join(".")} = ${valueLiteral};`).join("\n")}
return obj;`,
    ) as (value: T) => T;
}

type PathsAndValueLiterals = { path: string[]; valueLiteral: string }[];

function collectPathsAndValueLiterals(obj: any, base: string[], result: PathsAndValueLiterals) {
    for (const key in obj) {
        const path = [...base, key];
        const value = obj[key];
        switch (typeof value) {
            case "string":
            case "number":
            case "boolean":
                result.push({ path, valueLiteral: JSON.stringify(value) });
                continue;
            case "object":
                if (value === null) {
                    result.push({ path, valueLiteral: "null" });
                    continue;
                }
                if (isPojo(value)) {
                    collectPathsAndValueLiterals(value, path, result);
                    continue;
                }
            default:
                throw new Error(`unsupported value at ${path}: ${value}`);
        }
    }

    return result;
}

// https://stackoverflow.com/a/40456709
function isPojo(value: any) {
    return value.constructor === Object;
}
