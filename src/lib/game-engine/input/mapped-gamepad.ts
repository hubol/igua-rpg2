import { sqDistance } from "../../math/vector";
import { vnew } from "../../math/vector-type";
import { Undefined } from "../../types/undefined";
import { GamepadControlType, GamepadControls } from "./gamepad-controls";

export class MappedGamepad<TAction extends string> {
    private readonly _keys: string[];
    private readonly _actionWasDown: Record<TAction, boolean>;
    private readonly _actionIsDown: Record<TAction, boolean>;
    private readonly _copyDownFn: CopyStateFn<Record<TAction, boolean>>;
    private readonly _applyGamepadToInputFn: ApplyGamepadToInputFn<TAction>;

    constructor(readonly controls: GamepadControls<TAction>, private readonly _onConnected: () => void, private readonly _onButtonPressed: () => void) {
        this._keys = Object.keys(controls);
        this._actionWasDown = this._createActionDownRecord();
        this._actionIsDown = this._createActionDownRecord();
        this._copyDownFn = compileCopyStateFn(this._keys);
        this._applyGamepadToInputFn = compileApplyGamepadToInput(controls, { axisUnitDistance: 0.5, stickDeadZone: 0.3 });
        // TODO check if a gamepad is already available and fire _onConnected,
        // else subscribe to "gamepadconnected" event
        // console.log(this._applyGamepadToInputFn);
    }

    private _createActionDownRecord() {
        const object = {};
        for (const key of this._keys)
            object[key] = false;
        return object as Record<TAction, boolean>;
    }

    clear() {
        for (const key of this._keys) {
            this._actionWasDown[key] = false;
            this._actionIsDown[key] = false;
        }
    }

    tick() {
        const gamepad = tryGetGamepad();
        if (!gamepad)
            return; // TODO not sure if it should happen now

        this._copyDownFn(this._actionIsDown, this._actionWasDown);
        this._applyGamepadToInputFn(gamepad, this._actionIsDown);
    }

    isDown(action: TAction) {
        return this._actionIsDown[action];
    }

    isUp(action: TAction) {
        return !this._actionIsDown[action];
    }

    justWentDown(action: TAction) {
        return !this._actionWasDown[action] && this._actionIsDown[action];
    }

    justWentUp(action: TAction) {
        return this._actionWasDown[action] && !this._actionIsDown[action];
    }
}

function tryGetGamepad() {
    const gamepads = navigator.getGamepads();
    let mostRecentlyPressedGamepad = Undefined<Gamepad>();
    let maxTimestamp = -1;

    for (let i = 0; i < gamepads.length; i++) {
        const gamepad = gamepads[i];
        if (gamepad && gamepad.timestamp > maxTimestamp) {
            maxTimestamp = gamepad.timestamp;
            mostRecentlyPressedGamepad = gamepad;
        }
    }

    return mostRecentlyPressedGamepad;
}

interface GamepadConfig {
    stickDeadZone: number;
    axisUnitDistance: number;
}

type CopyStateFn<T> = (current: T, previous: T) => void;

function compileCopyStateFn<T>(keys: string[]): CopyStateFn<T> {
    return eval(`// Generated by src/lib/game-engine/input/mapped-gamepad.ts
// compileCopyStateFn
function copyDownFn(current, previous) {
        ${keys.map(key => `   previous.${key} = current.${key};`).join('\n')}
}
copyDownFn`);
}

type ApplyGamepadToInputFn<TAction extends string> = (gamepad: Gamepad, state: Record<TAction, boolean>) => void;

function compileApplyGamepadToInput<TAction extends string>(controls: GamepadControls<TAction>, config: GamepadConfig): ApplyGamepadToInputFn<TAction> {
    const axisUnitDistanceSquared = Math.pow(config.axisUnitDistance, 2);

    return eval(`// Generated by src/lib/game-engine/input/mapped-gamepad.ts
// compileApplyGamepadToInput
function vectorContext(v1, v2, sqDistance) {
    return function applyGamepadToState(gamepad, state) {
${Object.entries(controls).flatMap(([action, controls]) => {
        return `        state.${action} = ${(controls as GamepadControlType[]).map(control => {
            switch (control.kind) {
                case "button":
                    return `gamepad.buttons[${control.index}].pressed`;
                case "axis":
                    return `(Math.sign(gamepad.axes[${control.index}]) === ${control.sign} && Math.abs(gamepad.axes[${control.index}]) > ${config.stickDeadZone})`;
                case "axisUnit":
                    return `sqDistance(v1.at(gamepad.axes[${control.indices[0]}], gamepad.axes[${control.indices[1]}]), v2.at(${control.unit.x}, ${control.unit.y})) < ${axisUnitDistanceSquared}`;
                default:
                    throw new Error(`Unrecognized Control kind ${(control as any).kind}`);
            }
        }).join(`
            || `)};`;
    }).join('\n')}
    }
}
vectorContext`)(vnew(), vnew(), sqDistance);
}
