import { sqDistance } from "../../math/vector";
import { vnew } from "../../math/vector-type";
import { Undefined } from "../../types/undefined";
import { InputModalityType, MappedInputModality } from "./asshat-input";
import { GamepadControlType, GamepadControls } from "./gamepad-controls";

export class MappedGamepad<TAction extends string> implements MappedInputModality<TAction> {
    private readonly _keys: string[];
    private readonly _actionWasDown: Record<TAction, boolean>;
    private readonly _actionIsDown: Record<TAction, boolean>;
    private readonly _copyDownFn: CopyStateFn<Record<TAction, boolean>>;
    private readonly _applyGamepadToInputFn: ApplyGamepadToInputFn<TAction>;
    isCurrent = false;

    constructor(private readonly _controls: GamepadControls<TAction>) {
        this._keys = Object.keys(_controls);
        this._actionWasDown = this._createActionDownRecord();
        this._actionIsDown = this._createActionDownRecord();
        this._copyDownFn = compileCopyStateFn(this._keys);
        this._applyGamepadToInputFn = compileApplyGamepadToInput(_controls, {
            axisUnitDistance: 0.5,
            stickDeadZone: 0.3,
        });
    }

    readonly type = InputModalityType.Gamepad;
    lastEventTimestamp = -1;

    start(): void {
        // nop
    }

    private _createActionDownRecord() {
        const object = {};
        for (const key of this._keys) {
            object[key] = false;
        }
        return object as Record<TAction, boolean>;
    }

    clear() {
        for (const key of this._keys) {
            this._actionWasDown[key] = false;
            this._actionIsDown[key] = false;
        }
    }

    tick() {
        const gamepad = tryGetGamepad();
        if (!gamepad) {
            return; // TODO not sure if it should happen now
        }

        this._copyDownFn(this._actionIsDown, this._actionWasDown);
        this._applyGamepadToInputFn(gamepad, this._actionIsDown);

        for (let i = 0; i < gamepad.buttons.length; i += 1) {
            if (gamepad.buttons[i].pressed) {
                this.lastEventTimestamp = performance.now();
                break;
            }
        }
    }

    isDown(action: TAction) {
        return this._actionIsDown[action];
    }

    isUp(action: TAction) {
        return !this._actionIsDown[action];
    }

    justWentDown(action: TAction) {
        return !this._actionWasDown[action] && this._actionIsDown[action];
    }

    justWentUp(action: TAction) {
        return this._actionWasDown[action] && !this._actionIsDown[action];
    }
}

function tryGetGamepad() {
    // navigator.getGamepads() might throw
    // https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getGamepads#exceptions
    try {
        const gamepads = navigator.getGamepads();
        let mostRecentlyPressedGamepad = Undefined<Gamepad>();
        let maxTimestamp = -1;

        for (let i = 0; i < gamepads.length; i++) {
            const gamepad = gamepads[i];
            if (gamepad && gamepad.timestamp > maxTimestamp) {
                maxTimestamp = gamepad.timestamp;
                mostRecentlyPressedGamepad = gamepad;
            }
        }

        return mostRecentlyPressedGamepad;
    }
    catch (e) {
        return;
    }
}

interface GamepadConfig {
    stickDeadZone: number;
    axisUnitDistance: number;
}

type CopyStateFn<T> = (current: T, previous: T) => void;

function compileCopyStateFn<T>(keys: string[]): CopyStateFn<T> {
    return new Function(
        "current",
        "previous",
        `// Generated by src/lib/game-engine/input/mapped-gamepad.ts
// compileCopyStateFn
${keys.map(key => `previous.${key} = current.${key};`).join("\n")}`,
    ) as any;
}

type ApplyGamepadToInputFn<TAction extends string> = (gamepad: Gamepad, state: Record<TAction, boolean>) => void;

function compileApplyGamepadToInput<TAction extends string>(
    controls: GamepadControls<TAction>,
    config: GamepadConfig,
): ApplyGamepadToInputFn<TAction> {
    const axisUnitDistanceSquared = Math.pow(config.axisUnitDistance, 2);

    return new Function(
        "v1",
        "v2",
        "sqDistance",
        `// Generated by src/lib/game-engine/input/mapped-gamepad.ts
// compileApplyGamepadToInput
return function applyGamepadToState(gamepad, state) {
${
            Object.entries(controls).flatMap(([action, controls]) => {
                return `    state.${action} = ${
                    (controls as GamepadControlType[]).map(control => {
                        switch (control.kind) {
                            case "button":
                                return `gamepad.buttons[${control.index}].pressed`;
                            case "axis":
                                return `(Math.sign(gamepad.axes[${control.index}]) === ${control.sign} && Math.abs(gamepad.axes[${control.index}]) > ${config.stickDeadZone})`;
                            case "axisUnit":
                                return `sqDistance(v1.at(gamepad.axes[${control.indices[0]}], gamepad.axes[${
                                    control.indices[1]
                                }]), v2.at(${control.unit.x}, ${control.unit.y})) < ${axisUnitDistanceSquared}`;
                            default:
                                throw new Error(`Unrecognized Control kind ${(control as any).kind}`);
                        }
                    }).join(`
        || `)
                };`;
            }).join("\n")
        }
    }`,
    )(vnew(), vnew(), sqDistance);
}
